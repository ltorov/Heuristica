# -*- coding: utf-8 -*-
"""Heurística.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/10nCJO3OLM4xDGa7um0KuielhWeljREPC
"""

#pip install xlsxwriter

from zipfile import ZipFile
import pandas as pd
import numpy as np
import matplotlib as plt
import random
import math
from sklearn.cluster import KMeans
import time
import xlsxwriter
import os

"""#Auxiliary methods"""

def readFile(filename):
  """
  Takes a file name and returns the p, the nodes, and a dataframe of nodes.
  """
  f = open(filename, "r")
  firstrow = list(f.readline().split("\t"))
  nodes = int(firstrow[0])
  p = int(firstrow[1])
  dfnodes = pd.read_csv(filename, sep="\t")
  dfnodes.columns= ['x','y','Capacity','Demand']
  return p, nodes, dfnodes

def euclideanDistanceMatrix(nodes,dfnodes):
  """
  Returns Dij, a matrix containing, for each (i,j), the eucledean distance from 
  node i to node j.

  Parameters:
  nodes: int
  Total amount of nodes available

  df: pandas dataframe
  Contains the (x,y) coordinates as well as the capacity and the demand for each 
  node.
  """
  Dij = np.zeros([nodes,nodes])
  for i in range(nodes):
    for j in range(nodes):
      xi = dfnodes['x'][i]
      yi = dfnodes['y'][i]
      xj = dfnodes['x'][j]
      yj = dfnodes['y'][j]
      dij = math.sqrt((xj-xi)**2+(yj-yi)**2)
      Dij[i][j] = dij
  return Dij

def format(Xij, p, nodes, Dij, starttime, endtime):
  """
  Organizes the solution found in the format required.
  """
  f = []
  totaldist = 0
  sums = sum(Xij)
  for j in range(nodes):
    row = []
    dist = 0
    if (Xij[j][j]==1):
      row.append(j+1)
      row.append(int(sums[j]))
      for i in range(nodes):
          if (Xij[i][j]==1):
            dist = dist + Dij[i][j]
            row.append(i+1)
      row.append(dist)
      totaldist = totaldist+dist
      f.append(row)
  f.append([totaldist, (endtime-starttime)*1000])
  return f,totaldist

def readZip(zip):
  """
  Reads a zip file and unpacks its files, and returns arrays of solutions for 
  each method and file sizes.

  Parameter:
  zip: zip file
  """
  constructiveSolutions = []
  graspSolutions = []
  noiseSolutions = []
  filenames = []
  s = ZipFile('pmedcap.zip', 'r')
  with ZipFile(zip, mode="r") as archive:
    for filename in archive.namelist():
      if ("__MACOSX/" in filename) or ("DS_Store" in filename) or (filename == "pmedcap/"): 
        a=1
      else: 
        txtdata = s.extract(filename)
        p,nodes,dfnodes = readFile(txtdata)
        Dij = euclideanDistanceMatrix(nodes,dfnodes)
        f = constructive(p,nodes,dfnodes,Dij)
        constructiveSolutions.append(f)
        f = grasp(p,nodes,dfnodes,Dij)
        graspSolutions.append(f)
        f = constructiveNoise(p,nodes,dfnodes,Dij)
        noiseSolutions.append(f)
        filenames.append(filename)
  return constructiveSolutions,graspSolutions,noiseSolutions,filenames

def createExcel(solutions, filenames, excelName):
  """
  For an array of solutions returns an excel file with each solution for each
  file in a separate sheet.

  Parameters:
  solutions: array
  Array of solutions in the asked format.

  filenames: array
  Array of filenames contained in the zip files.

  excelName: string
  the asked for named for the excel files according to each method.
  """
  excel = xlsxwriter.Workbook(excelName)
  n = len(filenames)
  for m in range(n):
    filename = filenames[m].split("/",1)[1] 
    worksheet = excel.add_worksheet(filename)
    sol = solutions[m]
    for i in range(len(sol)):
      s = sol[i]
      for j in range(len(s)):
        worksheet.write(i,j,s[j])
  excel.close()
  return excel

"""#Constructive method"""

def chooseCenters(p,nodes,Dij):
  """
  Chooses the best centers, those that have the least total distance for each 
  node.
  """
  sumDij = sum(Dij)
  sumDij = sorted(range(len(sumDij)), key=lambda k: sumDij[k])
  chosen = sumDij[0:p]
  return chosen

def ranking(p, nodes, Dij, chosen):
  """
  Return a matrix containing from each node, the closest nodes to it in orden.
  """
  ranking = np.zeros([nodes,nodes])
  chosenranking = []
  completeranking = []
  for n in range(nodes):
    chosenranking = []
    di = Dij[n]
    ranking[n] = (sorted(range(len(di)), key=lambda k: di[k]))
    for rank in ranking[n]:
      if rank in chosen:
        chosenranking.append(int(rank))
    completeranking.append(chosenranking)
  return completeranking

def assignCenters(p,nodes,dfnodes,Dij, chosen):
  """
  Assigns all the other nodes to the chosen centers.

  Parameters:
  chosen: array
  Array of the centers.
  """
  Xij = np.zeros([nodes,nodes])
  rank = ranking(p,nodes,Dij,chosen)
  demand = np.array(dfnodes['Demand'])
  capacity = np.array(dfnodes['Capacity'])
  for i in range(nodes):
    if i in chosen:
      Xij[i][i] = 1
    else: 
      for j in rank[i]:
        if (j!=i):
          demandj = demand[int(j)]
          demandi = demand[i]
          capacityj = capacity[int(j)]
          if (capacityj >= demandj+demandi):
            Xij[i][int(j)] = 1
            demand[int(j)] += demandi
            demand[i] = 0
            break
  return Xij, demand, capacity

def feasible(demand,capacity):
  """
  Determines whether a solution given in the form Xij is feasible according to 
  the centers capacity and demand.
  Returns 1 when its feasible and 0 when its not.
  """
  ax = capacity-demand
  boo = True
  for a in ax:
    if a<0:
      boo = False
      break
  return boo

def constructive(p,nodes,dfnodes,Dij):
  starttime = time.time()
  chosen = chooseCenters(p,nodes,Dij)
  Xij,demand,capacity = assignCenters(p,nodes,dfnodes,Dij,chosen)
  endtime = time.time()
  f,totaldist = format(Xij, p, nodes, Dij, starttime, endtime)
  boo=feasible(demand,capacity)
  return f

"""# GRASP algorithm"""

"""
Hiperparámetros:

numberofsolutions: int
Number of random solutions generated
"""
numofsolutions = 100

def randomInitialization(p, nodes, dfnodes, Dij):
  """
  Picks p random nodes as centers and assigns them to all other nodes according
  to minimum euclidean distance.
  Returns Xij, an array where ones represent where the node is assigned to.

  Parameters:
  p: int
  P medians, number of nodes to be selected
  """
  Xjj = np.zeros(p, int)
  for i in range(p):
    index = random.randint(0, nodes-1)
    Xjj[i] = int(index)
  return Xjj



def grasp(p,nodes,dfnodes,Dij):
  starttime = time.time()
  bestf = 0
  bestdist = 10000000000000
  for i in range(numofsolutions):
    chosen = randomInitialization(p,nodes,dfnodes,Dij)
    endtime = time.time()
    Xij,demand,capacity = assignCenters(p,nodes,dfnodes,Dij,chosen)
    f,totaldist = format(Xij, p, nodes, Dij, starttime, endtime)
    boo = feasible(demand,capacity)
    if totaldist < bestdist:
      bestdist = totaldist
      bestf = f
  return bestf

"""# Constructive with noise"""

"""
Hiperparámetros:

n: float
Parameter of uniform distribution
"""
n = 1

def noise(p, nodes, dfnodes):
  """
  Returns the dataset with noise from a uniform distribution (-n,n).
  """
  dfnoise = dfnodes.copy()
  for i in range(nodes):
    rx = random.uniform(-n,n)
    ry = random.uniform(-n,n)
    dfnoise['x'][i] += rx
    dfnoise['y'][i] += ry
  return dfnoise

def constructiveNoise(p,nodes,dfnodes,Dij):
  """
  Returns the dataset with noise from a uniform distribution (-n,n).
  """
  starttime = time.time()
  dfnoise = noise(p,nodes,dfnodes)
  Dijnoise = euclideanDistanceMatrix(nodes,dfnoise)
  chosen = chooseCenters(p,nodes,Dijnoise)
  Xij,demand,capacity = assignCenters(p,nodes,dfnoise,Dijnoise,chosen)
  endtime = time.time()
  f,totaldist = format(Xij, p, nodes, Dij, starttime, endtime)
  boo = feasible(demand,capacity)
  return f

def main():
  constructiveSolutions,graspSolutions,noiseSolutions,filenames = readZip("pmedcap.zip")
  createExcel(constructiveSolutions,filenames,'pmedcap_LTV_Constructivo.xlsx')
  createExcel(graspSolutions,filenames,'pmedcap_LTV_GRASP.xlsx')
  createExcel(noiseSolutions,filenames,'pmedcap_LTV_ConstructivoConRuido.xlsx')
  
main()